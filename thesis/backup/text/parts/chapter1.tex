\chapter{Обзор предметной области}
\label{chapter1}

\section{Метрики покрытия кода}
Целью тестирования программного обеспечения является проверка требуемой функциональности. Существуют различные виды тестирования, например тестирование 
производительности или безопасности. Для оценки того, насколько хорошо данный набор тестов покрывает код, используются различные метрики. Зачастую полное 
покрытие кода в рамках выбранной метрики невозможно, поэтому набор тестов считается хорошим, если он покрывает 90~\%--95~\% кода.

Существует несколько различных способов задать метрику покрытия кода~\cite{ipl_cite,too_old_metrics}. Основные из них:
\begin{itemize}
 \item покрытие классов/методов --- проверяется, что каждый класс/метод вызывается;
 \item покрытие строк кода --- проверяется, что каждая строка программы выполняется;
 \item покрытие условий --- перебираются все значения условий;
 \item покрытие траекторий выполнения --- все ли возможные траектории через заданную часть кода были пройдены. 
\end{itemize}

Метрика покрытия классов/методов не применима для тестирования олимпиадных задач, поскольку при использовании данной метрики может быть не выявлено большое 
число ошибок. Однако, применение этих метрик оправдано при необходимости покрыть код, часть которого закрыта или не может быть профилирована по лицензионным 
соображениям.

В отличие от метрики покрытия строк кода, покрытие условий требует рассмотреть все варианты выполнения условия. Например, для условия $x \vee y$ при 
использовании метрики покрытия условий требуется рассмотреть варианты:
\begin{enumerate}
 \item $x = \texttt{true}$;
 \item $x = \texttt{false}$, $y = \texttt{true}$;
 \item $x = \texttt{false}$, $y = \texttt{false}$.
\end{enumerate}
Однако, используя метрику покрытия строк кода, можно ограничиться рассмотрением первого и третьего вариантов.

Для рассмотрения всех возможных траекторий обычно требуется перебрать большее число вариантов, чем при покрытии условий. При этом число траекторий 
может расти экспоненциально, что требует большого времени выполнения тестов. Поэтому данную метрику применяют лишь при разработке систем с повышенными 
требованиями к надежности. В данной работе используется метрика покрытия условий.

\section{Эволюционные алгоритмы}
Эволюционный алгоритм~\cite{general_EA}~--- это метод решения задач оптимизации. Данный подход основан на идеях, заимствованных из биологической эволюции: 
естественный отбор, мутация, скрещивания и наследование признаков. Каждая итерация алгоритма характеризуется набором особей, называемым поколением. На множестве 
особей вводят функции приспособленности, чтобы количественно оценивать, насколько заданная особь близка к верному решению. При помощи оператора скрещивания 
(кроссовера) по двум особям генерируется особь для следующего поколения. Оператор мутации вносит малые случайные изменения особи. Начальное поколение обычно 
формируется случайным образом. При выборе особей для создания нового поколения наиболее приспособленные имеют больше шансов. Общая схема эволюционного 
алгоритма представлена на листинге~\ref{lst:ea}.

\begin{algorithm}[h!]
\caption{Общая схема эволюционного алгоритма}
\label{lst:ea}
\begin{algorithmic}[1]
  \STATE {Создать начальное поколение}
  \STATE {Вычислить значение функции приспособленности для каждой особи}
  \WHILE {(условие останова эволюционного алгоритма не выполнено)}
    \STATE {Выбирается подмножество особей текущего поколения}
    \STATE {Применяя операторы мутации и кроссовера к выбранным особям, генерируются новые}
    \STATE {Вычисляется значение функции приспособленности для сгенерированных особей}    
    \STATE {Формируется новое поколение, заменяя новыми особями наименее приспособленных}
  \ENDWHILE  
\end{algorithmic}
\end{algorithm}

В качестве критерия останова часто используют следующие условия:
\begin{itemize}
 \item найдено верное решение;
 \item достигнуто заданное количество поколений;
 \item превышено заданное время работы;
 \item превышено заданное число вызовов функции приспособленности;
 \item за заданное число поколений не произошло улучшение.
\end{itemize}

Эволюционные алгоритмы применяются для решения задач, к которым не применимы традиционные методы оптимизации. Одной из областей применения эволюционных 
алгоритмов является автоматическая генерация тестов для программного обеспечения.

\section{Существующие подходы}
Рассмотрим некоторые методы, применяемые для автоматической генерации покрывающего набора тестов.

\subsection{Применение алгоритмов оптимизации}
Покрытие фрагмента кода тестом можно рассматривать как задачу оптимизации. В качестве оптимизируемой функции используется количественная оценка того, насколько 
сгенерированный тест покрывает заданный фрагмент кода.

Рассмотрим некоторые алгоритмы, применяемые для решения данной задачи \cite{review_harman,sbst}.
\begin{itemize}
 \item Алгоритм восхождения на вершину (\textit{Hill climbing}) \cite{hill_climbing_harman}. На каждой итерации алгоритма генерируется 
набор ``ближайших соседей'', полученный при помощи небольших изменений текущего кандидата. Существует два способа выбора кандидата для следующей итерации. Можно 
перебирать соседей, пока не найдется лучший кандидат, либо выбрать лучшего из всех соседей. Алгоритм завершает работу, если невозможно улучшить текущее 
решение. 
 \item Метод отжига \cite{SA}. В отличие от предыдущего алгоритма может выбрать худшее решение с некоторой вероятностью. Эта вероятность уменьшается с номером 
итерации алгоритма. Вследствие этого данный подход менее подвержен схождению в локальному оптимуму вместо глобального.

 \item Применение эволюционных алгоритмов для построения набора тестов получило широкое распространение 
\cite{evolutionary_tonella,whole_test_suite_generation,structural_test_data_generation}. Используются различные эволюционные операторы, функции 
приспособленности, а также по-разному кодируются особи. Однако не существует оптимального подхода.
\end{itemize}

\subsection{Символьное выполнение}
При символьном выполнении~\cite{symbolic_sbst} моделируется выполнение программы, при котором часть входных переменных представляется в символьном виде. Можно 
выделить два основных подхода~\cite{symbolic_execution}: на основе статического или динамического анализа программы.

При статическом подходе для каждой возможной траектории выполнения с помощью символьного выполнения задаются ограничения на параметры тестируемой программы. 
Если для некоторой траектории возможно удовлетворить все ограничения, то вдоль нее будет сгенерирован тест.

Однако статический подход неприменим, если тестируемая программа содержит ограничения вне области видимости статического анализатора. Рассмотрим программу, 
приведенную на листинге~\ref{lst:bad_static}.

\begin{snippet}[caption={Пример, на котором не применим статический подход}, label={lst:bad_static}]
  def testMethod(x, y) {
      if (x == hash(y)) {
          return 0	// %*целевое ветвление*)
      }
      return 1
  }
\end{snippet}

Допустим, что в целях безопасности, анализатор кода не имеет доступ к функции \texttt{hash}. Значит, без запуска программы невозможно подобрать \texttt{x} так, 
чтобы он был равен \texttt{hash(y)}.

Для обхода таких ситуаций используется динамический подход. При этом генерация теста происходит следующим образом:
\begin{enumerate}
 \item Тестируемая программа выполняется на случайных входных данных.
 \item Динамический анализатор записывает ограничения на входные параметры тестируемой программы вдоль траектории выполнения.
 \item Удовлетворив ограничениям, подбирается такой тест, чтобы следующий запуск прошел по другой траектории.
\end{enumerate}

Таким образом, при запуске программы~\ref{lst:bad_static} на случайных значениях, будет посчитано \texttt{hash(y)}. Взяв посчитанное значение \texttt{hash(y)} 
вместо \texttt{x}, можно удовлетворить ограничениям.

При использовании данного подхода возникают проблемы с масштабированием \cite{symbolic_limitations}. При тестировании более сложных программ возрастает как 
длина траекторий выполнения, так и число символьных переменных. При увеличении количества ограничений, накладываемых на параметры тестируемой программы, 
существенно увеличивается время, затрачиваемое на их удовлетворение.

\section{Java Virtual Machine}

В данной работе рассматривается покрытие тестами программ, работающих на \textit{Java Virtual Machine (JVM)}. \textit{JVM}~\cite{jvm_spec} 
--- основа \textit{Java} платформы, отвечающая за аппаратную и операционную независимость программ. \textit{JVM} имеет определенный набор инструкций и 
управляет памятью во время выполнения программы. \textit{JVM} работает с файлами определенного бинарного формата, называемыми \textit{class}-файлами, в которых 
содержатся последовательность инструкций, таблица символов и другая вспомогательная информация.

\subsection{Типы данных}
Типы данных \textit{JVM} делятся на примитивные и ссылочные. Для каждой инструкции определен тип аргументов, к которым она применяется. Например, инструкции 
\texttt{iadd}, \texttt{ladd}, \texttt{fadd} и \texttt{dadd} складывают два численных значения и возвращают результат, но каждая из этих инструкций 
предназначена для определенного типа данных: \texttt{int}, \texttt{long}, \texttt{float} и \texttt{double} соответственно.

Примитивные типы данных делятся на численные, логический (\texttt{boolean}) тип и тип адреса возврата (\texttt{returnAddress}). В свою очередь, числовые типы 
данных делятся на:
\begin{itemize}
 \item целочисленные
 \begin{itemize}
  \item \texttt{byte}, от $-127$ до $128$
  \item \texttt{short}, от $-2^{15}$ до $2^{15} - 1$
  \item \texttt{int}, от $-2^{31}$ до $2^{31} - 1$
  \item \texttt{long}, от $-2^{63}$ до $2^{63} - 1$
  \item \texttt{char}, символ Unicode, 2 байта
 \end{itemize}
 \item числа с плавающей точкой, соответствующие стандарту IEEE 754
 \begin{itemize}
  \item \texttt{float}, 32-битное вещественное число одинарной точности
  \item \texttt{double}, 64-битное вещественное число двойной точности
 \end{itemize}
\end{itemize}

Значениями, имеющими тип адреса возврата, являются указатели на инструкции \textit{JVM}. В отличие от данных численных типов, значения типа адреса возврата не 
могут быть изменены в процессе работы программы.

Несмотря на то, что \textit{JVM} декларирует тип \texttt{boolean}, для него предоставляется лишь ограниченная поддержка. \textit{JVM} не имеет инструкций, 
специально предназначенных для значений типа \texttt{boolean}. Для работы со значениями типа \texttt{boolean} используются инструкции, предназначенные для 
работы со значениями типа \texttt{int}, причем \texttt{true} соответствует единица, а \texttt{false}~--- ноль.

Cсылочные типы данных делятся на классы, массивы и интерфейсы. Данными, имеющими такие типы, соответственно являются динамически создаваемые экземпляры 
классов, массивов, а также экземпляры классов и массивы, которые реализуют заданный интерфейс.

В процессе выполнения программы \textit{JVM} некоторые типы данных хранятся одинаково, причем размер выделяемой памяти зависит от категории типа. Способ 
хранения типы данных зависит от соответствующего ему типа данных времени выполнения. Соответствие фактических типов данных и типов времени выполнения, а также 
категории указаны в таблице~\ref{tab:type_compatibility}.

\begin{table}[ht]
\caption{Таблица соответствий типов данных \textit{JVM}}
\label{tab:type_compatibility}
\begin{tabular}{|c|c|c|}
\hline
Фактический тип & Тип времени выполнения & Категория \\
\hline
\texttt{boolean} & \texttt{int} & 1 \\
\hline
\texttt{byte} & \texttt{int} & 1 \\
\hline
\texttt{char} & \texttt{int} & 1 \\
\hline
\texttt{short} & \texttt{int} & 1 \\
\hline
\texttt{int} & \texttt{int} & 1 \\
\hline
\texttt{float} & \texttt{float} & 1 \\
\hline
\texttt{reference} & \texttt{reference} & 1 \\
\hline
\texttt{returnAddress} & \texttt{returnAddress} & 1 \\ 
\hline
\texttt{long} & \texttt{long} & 2 \\
\hline
\texttt{double} & \texttt{double} & 2 \\
\hline
\end{tabular}
\end{table}

\subsection{Среда выполнения}
\label{jvm_env}
Во время работы \textit{JVM} использует память двух видов: куча и стек.

Куча предназначена для хранения экземпляров классов и массивов. Очистка кучи происходит автоматически с помощью сборщика мусора. Куча общая для всех потоков 
\textit{JVM} и инициализируется при старте \textit{JVM}.

В отличие от  кучи, стек для каждого потока свой. Его инициализация происходит в момент создания потока.

При выполнении программы на каждый вызов метода создается фрейм~--- данные, необходимые для выполнения метода~--- который кладется на стек. После завершения 
выполнения метода фрейм удаляется со стека, вне зависимости от того, было ли брошено необработанное исключение или нет.

Фрейм, соответствующий методу, выполняемому в данный момент, называется активным. После завершения текущего метода, активным становится предыдущий фрейм. 
Каждый фрейм выделяется локально для каждого потока, поэтому остальные потоки не могут на него ссылаться.

Каждый фрейм содержит:
\begin{itemize}
 \item набор локальных переменных;
 \item стек операндов;
 \item ссылку на набор констант текущего метода.
\end{itemize}

Локальные переменные пронумерованы, начиная с нуля, и обращение к ним происходит по соответствующему номеру. \textit{JVM} использует локальные переменные для 
передачи параметров при вызове метода, причем нулевым параметром является ссылка на объект, чей метод был вызван. Для хранения значений типа, относящегося 
первой категории, используется одна локальная переменная, а для значений типа, относящегося ко второй категории, используются две последовательные локальные 
переменные.

Максимальный размер стека операндов определяется на этапе компиляции. При выполнении инструкции аргументы забираются со стека операндов и результат выполнения 
кладется на стек. Кроме того, стек операндов используется для передачи аргументов вызываемым методам. При вызове метода аргументы забираются со стека операндов 
текущего фрейма, создается новый фрейм и аргументы сохраняются в локальных переменных созданного фрейма. Результат кладется на стек операндов того фрейма, из 
которого был вызван метод. После этого созданный фрейм удаляется. Значения типов данных, относящихся первой категории, занимают одну ячейку стека операндов, в 
то время как значения типов, относящихся второй категории~--- две.

Каждый класс и интерфейс имеет набор констант. В нем содержатся как численные константы, известные на момент компиляции, так и ссылки на методы и поля, 
значения которых вычисляются во время выполнения.

\subsection{Набор инструкций}
Перечислим инструкции \textit{JVM}, которые затронуты в данной работе. 
% Подробное описание инструкций приведено в приложении [ссылка].

\subsubsection{Инструкции сохранения и загрузки}
Инструкции загрузки и сохранения предназначены для передачи значений между стеком операндов и локальными переменными:

\begin{itemize}
 \item Загрузка значений из локальной переменной на стек операндов: \texttt{iload}, \texttt{fload}, \texttt{dload}, \texttt{lload}, \texttt{aload};
 \item Сохранение значений со стека операндов в локальные переменные: \texttt{istore}, \texttt{fstore}, \texttt{dstore}, \texttt{lstore}, \texttt{astore};
 \item Загрузка констант на стек операндов: \texttt{bipush}, \texttt{sipush}, \texttt{ldc}, \texttt{aconst\_null}, \texttt{iconst}, \texttt{fconst}, 
\texttt{lconst}, \texttt{dconst}.
\end{itemize}

\subsubsection{Инструкции ветвления}
\begin{itemize}
 \item Сравнение двух операндов типа \texttt{int}: \texttt{if\_icmpeq}~($=$), \texttt{if\_icmpne}~($\neq$), \texttt{if\_icmplt}~($<$), 
\texttt{if\_icmpge}~($\ge$), \texttt{if\_icmpgt}~($>$), \texttt{if\_icmple}~($\le$);
 \item Сравнение операнда типа \texttt{int} c нулем: \texttt{ifeq}, \texttt{ifne}, \texttt{iflt}, \texttt{ifge}, \texttt{ifgt}, \texttt{ifle};
 \item Сравнение ссылочных типов: \texttt{if\_acmpeq}, \texttt{if\_acmpne}, \texttt{ifnonnull}, \texttt{ifnull};
 \item Сравнения: \texttt{dcmpg}, \texttt{dcmpl}, \texttt{fcmpg}, \texttt{fcmpl}, \texttt{lcmp}.
\end{itemize}

\section{Scala}
\textit{Scala}~\cite{scala_lang}~--- статически типизированный язык программирования, сочетающий в себе возможности объектно-ориентированного и функционального 
программирования. Система типов \textit{Scala} специально спроектирована для удобства создания компонентного программного обеспечения. При этом \textit{Scala} 
полностью совместима с \textit{Java}.

В отличие от \textit{Java}, в \textit{Scala} имеется поддержка типажей (\texttt{trait}), которые подобны интерфейсам, но могут содержать реализацию методов. 
Как и в случае с интерфейсами, возможно множественное наследование от типажей. При определении типажа можно указывать дополнительные типажи, необходимые 
создания его экземпляра. Это можно использовать для конфигурации эволюционного алгоритма (ЭА). 

Рассмотрим пример, приведенный на листинге~\ref{lst:scala_config}. При создании экземпляра ЭА (\textit{EvolutionaryAlgorithm}) необходимо указать оператор 
мутации (\textit{Mutation}).Таким образом, можно использовать один и тот же ЭА, но с различными операторами мутации. В приведенном примере определено 
два типажа мутации целого числа: \textit{IncrementMutation} и \textit{SquareMutation}. Экземпляры ЭА~--- \textit{incEA} и \textit{squareEA}~--- различаются
используемыми операторами мутации.

\begin{snippet}[caption=Пример конфигурации эволюционного алгоритма, label={lst:scala_config}]
trait Mutation[G] {  
  def mutate(g : G) : G
}

trait EvolutionaryAlgorithm[G] {
  needs : Mutation[G] =>  // %*определение необходимого типажа*)
  ...
}

trait IncrementMutation extends Mutation[Int] {
  def mutate(g : Int) = g + 1
}

traint SquareMutation extends Mutation[Int] {
  def mutate(g : Int) = g * g
}

val incEA = new EvolutionaryAlgorithm[Int] with IncrementMutation

val squareEA = new EvolutionaryAlgorithm[Int] with SquareMutation
\end{snippet}

\section{Выводы по главе \ref{chapter1}}
Рассмотрены некоторые существующие подходы к автоматизированному покрытию кода тестами. Описаны различные структурные метрики покрытия кода. Кратко описана 
спецификация \textit{JVM}. Кратко описаны особенности языка программирования \textit{Scala}.





