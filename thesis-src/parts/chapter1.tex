\chapter{Обзор
% предметной области
}
\label{chapter1}

В данной главе производится обзор предметной области и даются определения используемых терминов.

\section{Функциональное программирование}

\emph{Функциональное программирование} — парадигма программирования,
являющаяся разновидностью декларативного программирования,
в которой программу представляют в виде функций
(в математическом смысле этого слова, а не в смысле, используемом в процедурном программировании),
а выполнением программы считают вычисление значений применения этих функций к заданным значениям.
Большинство функциональных языков программирования используют в своём основании лямбда-исчисление
(например, Haskell~\cite{HaskellLang}, Curry~\cite{CurryLang}, Agda~\cite{AgdaLang},
диалекты LISP~\cite{SchemeLang,ClojureLang,SICP}, SML~\cite{SMLLang}, OCaml\cite{OCamlLang}),
но существуют и функциональные языки явно не основанные на этом формализме
(например, препроцессор языка C и шаблоны в C++).

\section{Лямбда-исчисление}

\emph{Лямбда-исчисление} ($\lambda$-calculus)~— вычислительный формализм
с тремя синтаксическим конструкциями, называемыми \emph{пре-лямбда-термами}:
\begin{itemize}
\item \emph{вхождение переменной}: $v$. При этом $v \in V$, где $V$~— некоторое множество имён переменных;
\item \emph{лямбда-абстракция}: $\lambda x.A$, где $x$~— имя переменной, а $A$~— пре-лямбда-терм. При этом терм $A$ называют \emph{телом абстракции}, а $x$ перед точкой~— \emph{связыванием}.
\item \emph{лямбда-аппликация}: $B C$;
\end{itemize}
и одной операцией \emph{бета-редукции}.
При этом говорят, что вхождение переменной является \emph{свободным},
если оно не связано какой-либо абстракцией.
Множество пре-лямбда-термов обозначают $\Lambda^{-}$.
\emph{Лямбда-термы}~— это пре-лямбда-термы, факторизованные по отношению \emph{альфа-эквивалентности}.
Обозначение: $\Lambda = \Lambda^{-} / =_{\alpha} $.

\emph{Альфа-эквивалентность} ($\alpha$-equality) отождествляет два пре-лямбда-терма, если один из них может быть получен из другого путём некоторого \emph{корректного} переименовывания переменных~— переименования не нарушающего отношение связанности.

\emph{Бета-редукция} ($\beta$-reduction) для лямбда-терма $A$ выбирает в нём некоторую лямбда-аппликацию $B C$, содержащую лямбда-абстракцию в левой части $A$, и заменяет свободные вхождения переменной, связанной $A$, в теле самой $A$ на терм $C$.\footnote{В терминах пре-лямбда-термов это означает замену свободных вхождений в теле $A$ на пре-терм $C$ так, чтобы ни для каких переменных не нарушилось отношение связанности. То есть, в пре-терме $A$ следует корректно переименовать все связанные переменные, имена которых совпадают с именами свободных переменных в $C$.}

Два лямбда-терма $A$ и $B$ называются \emph{конвертабельными},
когда существует две последовательности бета-редукций, приводящих их к общему терму $C$.
Или, эквивалентно, когда термы $A$ и $B$ состоят с друг с другом в рефлексивно-симметрично-транзитивном замыкании отношения бета-редукции, также называемом отношением \emph{бета-эквивалентности}.

За более подробной информацией об этом формализме следует обращаться к~\cite{TTFP} и~\cite{Sorensen}.

\section{Лямбда-исчисление с простыми типами}
\begin{definition}
    Пусть $U$ — бесконечное счетное множество, элементы которого мы будем
    называть \emph{переменными типов}.
    Множество \emph{простых типов} $\Pi$ — множество, определенное грамматикой:

    $$ \Pi ::= U \mid (\Pi \to \Pi) $$

    Для обозначения элементов множества $\Pi$ используют буквы греческого алфавита:
    $\sigma, \tau \ldots $.
\end{definition}
\begin{definition}
    Множество контекстов $C$ — это множество всех множеств пар такого вида:
    $$ \{ x_1 : \tau_1 , \ldots , x_n : \tau_n \} $$
    где $ \tau_1 , \ldots , \tau_n \in \Pi$, а
    $ x_1 , \ldots , x_n \in V $ (переменные из $\Lambda$) и $x_i \neq x_j$ если $i \neq j$.
\end{definition}
\begin{definition}
    \emph{Домен} контекста $\Gamma$ = $ \{ x_1 : \tau_1 , \ldots , x_n : \tau_n \} $:
    $$ \operatorname{dom} (\Gamma) = \{ x_1 , \ldots , x_n \} $$ и $x_i \neq x_j$ при $i \neq j$.
\end{definition}
\begin{definition}
    Отношение \emph{типизации} (typability) $ \vdash $ на множестве
    $ C \times \Lambda \times \Pi $ определяется следующими правилами:

    $$ \frac {} {\Gamma, x : \tau \vdash x : \tau}
    \quad
    \frac{\Gamma, x : \sigma \vdash M : \tau}
    {\Gamma \vdash \lambda x . M : \sigma \to \tau}
    \quad
    \frac{\Gamma \vdash M : \sigma \to \tau \quad \Gamma \vdash N : \sigma}
    {\Gamma \vdash M N : \tau}
    $$
    В первом и втором правиле мы требуем $x \notin \operatorname{dom}(\Gamma).$
\end{definition}
\begin{definition}
    \emph{Лямбда-исчисление с простыми типами} или $\lambda^{\to}$ — это тройка
    $ (\Lambda , \Pi , \vdash) $.
    Чтобы отличать данное в этой работе определение системы $\lambda^{\to}$ от других вариантов,
    эту систему называют лямбда-исчисление с простыми типами \emph{по Карри}.
\end{definition}
За более подробной информацией об этом формализме следует
обращаться к~\cite{ChurchSTLC} и~\cite{Sorensen}.

\section{Алгебраические типы данных и сопоставление с образцом}

\emph{Алгебраический тип данных} — вид составного типа, то есть типа,
сформированного комбинированием других типов.
Комбинирование осуществляется с помощью алгебраических операций — сложения и умножения.

\emph{Сумма} типов $A$ и $B$ — дизъюнктное объединение исходных типов.
Значения типа-суммы обычно создаются с помощью \emph{конструкторов}.

\emph{Произведение} типов $A$ и $B$ — прямое произведение исходных типов,
кортеж типов.

\subsection{Рекурсивные типы данных}
\emph{Рекурсивный тип данных} — тип данных, в определении которого содержится
определяемый тип данных. Например, список элементов типа $A$:
$$ List\;A = Nil + (A \times List\;A) $$

В теории~\cite{TAPL} для введения рекурсивных типов используются $\mu$-типы.
\emph{Сырые} $\mu$-типы вводятся с помощью оператора $\mu$: $\mu X . T $.
При этом $T$ может содержать $X$.

\begin{definition}
Сырой $\mu$-тип $T$ называется \emph{сократимым} (contractive),
если для любого подвыражения $T$ вида $ \mu X. \mu X_1 \ldots \mu X_n . S $
тело $S$ не равняется $X$.

Сырой $\mu$-тип называется просто \emph{$\mu$-типом} ($\mu$ -type), если он сократим.
\end{definition}
Пример: список элементов типа $A$: $ List\;A = \mu X . Nil + (A \times X)$.

\subsection{Сопоставление с образцом}

\emph{Сопоставление с образцом} — способ обработки
объектов % | значений |
алгебраических типов данных, который идентифицирует значения по конструктору
и извлекает данные в соответствии с представленным образцом.

\section{Теория типов}

\emph{Теория типов} — раздел математики изучающий отношения типизации вида
$ M \colon \tau $ и их свойства. $M$ называется \emph{термом} или \emph{выражением},
а $\tau$ — типом терма $M$.

Теория типов также изучает правила для \emph{переписывания} термов — замены
подтермов в выражениях другими термами.
Такие правила также называют правилами \emph{редукции} или \emph{конверсии} термов.
Редукцию терма $x$ в терм $y$ записывают: $x \to y$.
Также рассматривают транзитивное замыкание отношения редукции: $ \xrightarrow{*} $.
Например, термы $2 + 1$ и $3$ — разные термы, но первый редуцируется во второй:
$2 + 1 \xrightarrow{*} 3$.
Если для терма $x$ не существует терма $y$, для которого $x \to y$,
то говорят, что терм $x$ — в \emph{нормальной форме}.

\subsection{Отношение конвертабельности}

Два терма $x$ и $y$ называются \emph{конвертабельными},
если существует терм $z$ такой, что $x \xrightarrow{*} z$ и $y \xrightarrow{*} z$. Обозначают  $x \xleftrightarrow{*} y$.
Например, $1+2$ и $2+1$ — конвертабельны, как и термы
$x + (1 + 1)$ и $x + 2$. Однако, $x+1$ и $1+x$ (где $x$ — свободная переменная)
— не конвертабельны, так как оба представлены в нормальной форме.
Конвертабельность — рефлексивно-транзитивно-симметричное замыкание отношения
редукции.

\subsection{Интуиционистская теория типов}

Интуиционистская теория типов (теория типов Мартина-Лёфа)
основана на математическом конструктивизме~\cite{MLTT}.

Операторы для типов в ИТТ:
\begin{itemize}
    \item $\Pi$-тип (пи-тип) — зависимое произведение, обобщение типов функций ($ X \to Y $),
        в которых тип результата зависит от значения аргумента: $\Pi_{x : X} Y(x)$.
        Например, если $\operatorname{Vec}(A, n)$ — тип кортежей из $n$ элементов типа $A$,
        $\mathbb N$ — тип натуральных чисел, то
        $\Pi_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}(A, n)$ 
        — тип функции, которая по натуральному числу $n$ возвращает кортеж из
        $n$ элементов типа $A$.
    \item $\Sigma$-тип — зависимая пара $\Sigma_{x : A} B(x)$.
        Второй элемент в зависимой паре зависит от первого.
        Например, тип $\Sigma_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}(A, n)$ — тип 
        пары из числа $n$ и кортежа из $n$ элементов типа $A$.
    \item Пусть $A$ — множество конструкторов, $B$ — селектор на $A$.
        Элементы множества $A$ представляют разные способы сформировать
элемент в $W_{a : A} B(a) $, а $B(a)$ представляют части дерева, сформированные с помощью $a$.
        $W_{a : A} B(a) $  — рекурсивный тип, построенный с помощью конструкторов $B(a)$,
        который можно представить в виде \emph{фундированных деревьев} (well-founded trees)~\cite{WTypes}.
\end{itemize}
Базовые типы в ИТТ:
$\bot$ или $0$ — пустой тип, не содержащий ни одного элемента;
$\top$ или $1$ — единичный тип, содержащий единственный элемент.

\section{Унификация}

\emph{Унификатор} для термов $A$ и $B$ — подстановка $S$, действующая на их
свободные переменные, такая что $S(A) \equiv S(B)$.

\emph{Унификация} — процесс поиска унификатора.

\section{Agda}
\emph{Agda}~\cite{AgdaLang}~—  чистый функциональный язык программирования с зависимыми типами.
\input{latex/AgdaDescription.tex}

\section{Индуктивные семейства}

\begin{definition}
\emph{Индуктивное семейство}~\cite{DybjerIndFam, RefiningIT}~— это индуктивный тип данных,
который может зависеть от других типов и значений.
Тип или значение, от которого зависит зависимый тип, называют \emph{индексом}.
\end{definition}

Одной из областей применения индуктивных семейств являются системы интерактивного
доказательства теорем.

Индуктивные семейства позволяют формализовать математические структуры,
кодируя утверждения о структурах в них самих,
тем самым перенося сложность из доказательств в определения.

\section{Использование индуктивных семейств в структурах данных}
В работах~\cite{HongweiXi, McBridePivotal} приведены различные подходы
в использовании индуктивных семейств в реализации структур данных
и доказательств их свойств.

Пример задания структуры данных и инвариантов — тип данных AVL-дерева
и тип данных для хранения баланса высоты поддеревьев в AVL-дереве~\cite{AVLTree}.

\input{latex/AVLBalance.tex}

В работе~\cite{McBridePivotal} представлен способ обобщения
упорядоченных структур данных
(таких как отсортированные списки и деревья поиска)
и использование этого метода для реализации 2-3 деревьев.

\section{Выводы по главе~\ref{chapter1}}

В этой главе были рассмотрены некоторые существующие подходы к построению структур данных
с использованием индуктивных семейств.
Кратко описаны особенности языка программирования \textit{Agda},
который использован в этой работе.
