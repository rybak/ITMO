\chapter{Обзор
% предметной области
}
\label{chapter1}

В данной главе производится обзор предметной области и даются определения используемых терминов.

\section{Лямбда-исчисление}

\emph{Лямбда-исчисление} ($\lambda$-calculus)~--- вычислительный формализм с тремя синтаксическим конструкциями, называемыми \emph{пре-лямбда-термами}:
\begin{itemize}
\item \emph{вхождение переменной}: $v$. При этом $v \in V$, где $V$~--- некоторое множество имён переменных;
\item \emph{лямбда-абстракция}: $\lambda x.A$, где $x$~--- имя переменной, а $A$~--- пре-лямбда-терм. При этом терм $A$ называют \emph{телом абстракции}, а $x$ перед точкой~--- \emph{связыванием}.
\item \emph{лямбда-аппликация}: $B C$;
\end{itemize}
и одной операцией \emph{бета-редукции}.
При этом говорят, что вхождение переменной является \emph{свободным}, если оно не связано какой-либо абстракцией.
\emph{Лямбда-термы}~--- это пре-лямбда-термы, факторизованные по отношению \emph{альфа-эквивалентности}.

\emph{Альфа-эквивалентность} ($\alpha$-equality) отождествляет два пре-лямбда-терма, если один из них может быть получен из другого путём некоторого \emph{корректного} переименовывания переменных~--- переименования не нарушающего отношение связанности.

\emph{Бета-редукция} ($\beta$-reduction) для лямбда-терма $A$ выбирает в нём некоторую лямбда-аппликацию $B C$, содержащую лямбда-абстракцию в левой части $A$, и заменяет свободные вхождения переменной, связанной $A$, в теле самой $A$ на терм $C$.\footnote{В терминах пре-лямбда-термов это означает замену свободных вхождений в теле $A$ на пре-терм $C$ так, чтобы ни для каких переменных не нарушилось отношение связанности. То есть, в пре-терме $A$ следует корректно переименовать все связанные переменные, имена которых совпадают с именами свободных переменных в $C$.}

Два лямбда-терма $A$ и $B$ называются \emph{конвертабельными}, когда существует две последовательности бета-редукций, приводящих их к общему терму $C$.
Или, эквивалентно, когда термы $A$ и $B$ состоят с друг с другом в рефлексивно-симметрично-транзитивном замыкании отношения бета-редукции, также называемом отношением \emph{бета-эквивалентности}.

За более подробной информацией об этом формализме следует обращаться к~\cite{TTFP} и~\cite{Sorensen}.

\section{Функциональное программирование}

\emph{Функциональное программирование} — парадигма программирования,
являющаяся разновидностью декларативного программирования,
в которой программу представляют в виде функций
(математическом смысле этого слова, а не в смысле, используемом в процедурном программировании),
а выполнением программы считают вычисление значений применения этих функций к заданным значениям.
Большинство функциональных языков программирования используют в своём основании лямбда-исчисление
(например, Haskell~\cite{TODO}, Curry~\cite{TODO}, Agda~\cite{TODO}, диалекты LISP~\cite{TODO,SICP}, SML~\cite{TODO}, OCaml\cite{TODO}),
но существуют и функциональные языки явно не основанные на этом формализме
(например, препроцессор языка C и шаблоны в C++).

\section{Алгебраические типы данных и сопоставление с образцом}

% надо подробнее в таком примерно роде что я сделал выше
%
% \emph{Сопоставление с образцом} — способ реализации функций,
% при котором аргументы функций сравниваются (по значению или по структуре)
% с образцом такого же типа.

\section{Теория типов}

% ужасно от сюда и до Agda
% Теория типов — раздел математики изучающий отношения типизации вида M : τ и их свойства.
\emph{Теория типов} — какая-либо формальная система, являющаяся альтернативой
наивной теории множеств, сопровождаемая классификацией элементов такой системы
с помощью типов, образующих некоторую иерархию.
Элементы теории типов — выражения, также называемые \emph{термами}.
Если терм $ M $ имеет тип $A$, то это записывают так: $ M : A $.
Например, $ 2 : \mathbb{N} $.

Теории типов также содержат правила для переписывания термов — замены
подтермов формулы другими термами.
Такие правила также называют правилами \emph{редукции}
или \emph{конверсии} термов.
Например, термы $2 + 1$ и $3$ — разные термы, но первый редуцируется во второй:
$2 + 1 \twoheadrightarrow 3$.
Про терм, который не может быть редуцирован, говорят,
что терм — в \emph{нормальной форме}.

\subsection{Отношение конвертабельности}

Два терма называются \emph{конвертабельными}, если существует терм, к которому
они оба редуцируются. Например, $1+2$ и $2+1$ — конвертабельны, как и термы
$x + (1 + 1)$ и $x + 2$. Однако, $x+1$ и $1+x$ (где $x$ — свободная переменная)
— не конвертабельны, так как оба представлены в нормальной форме.

\subsection{Интуиционистская теория типов}

Интуиционистская теория типов основана на математическом конструктивизме \cite{MLTT}.

Операторы для типов в ИТТ:
\begin{itemize}
    \item $\Pi$-тип (пи-тип) — зависимое произведение.
        Например, если $\operatorname{Vec}({\mathbb R}, n)$ — тип кортежей из $n$ вещественных чисел,
        $\mathbb N$ — тип натуральных чисел, то
        $\Pi_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}({\mathbb R}, n)$ 
        — тип функции, которая по натуральному числу $n$ возвращает кортеж из
        $n$ вещественных чисел.
    \item $\Sigma$-тип — зависимая сумма (пара).
        Например, тип $\Sigma_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}({\mathbb R}, n)$ — тип 
        пары из числа $n$ и кортежа из $n$ вещественных чисел.
\end{itemize}
Конечные типы в ИТТ:
$\bot$ или $0$ — пустой тип, не содержащий ни одного элемента;
$\top$ или $1$ — единичный тип, содержащий единственный элемент.
\emph{Тип равенства}: для $x$ и $y$ выражение
$x \equiv y$ обозначает тип доказательства равенства $x$ и $y$.
То есть, если тип $x \equiv y$ населен, то $x$ и $y$ называются равными.
Есть только один каноничный элемент типа $x \equiv x$ — доказательство
рефлексивности: $refl : \Pi_{a : A} a \equiv a $.

\section{Унификация}

% унификатор для термов A и В — подстановка S действующая на их свободные переменные, такая что S(A) == S(B).
% унификация — процесс поиска унификатора.

Унификация — процесс и алгоритм решения уравнений над выражениями в теории типов.
Алгоритм унификации находит подстановку, которая назначает значение
каждой переменной в выражении, после применения которой,
части уравнения становятся конвертабельными.
Пример: равенство двух списков $cons(x,cons(x,nil)) \equiv cons(2,y) $
— уравнение с двумя переменными $x$ и $y$.
Решение: подстановка $ x \mapsto 2, y \mapsto cons(2,nil) $.

% * Очень кратко о ФП и паттерн-матчинге.
% * Кратко о теории типов, отношении конвертабельности и Мартине-Лёфе.
% * Кратко об унификации и индексированных семействах.
% * Кратко об Агда.
% * Об известных штуках кодируемых индексируемыми семействами (ссылки из
%   статьи МакБрайда).
\section{Индуктивные семейства}

\begin{definition}
\emph{Индуктивное семейство} \cite{DybjerIndFam}— это семейство типов данных,
которые могут зависеть от других типов и значений.

Тип или значение, от которого зависит зависимый тип, называют \emph{индексом}.
\end{definition}

Одной из областей применения индуктивных семейств являются системы интерактивного
доказательства теорем.

Индуктивные семейства позволяют формализовать математические структуры,
кодируя утверждения о структурах в них самих, тем самым перенося сложность из
доказательств в определения.

% \section{Существующие подходы}
В работах \cite{OkasakiThesis, McBridePivotal} приведены различные подходы
к построению функциональных структур данных.

Пример задания структуры данных и инвариантов —
тип данных AVL-дерева и для хранения баланса в AVL-дереве \cite{AVLTree}.
\newline
\input{latex/AVLBalance.tex}

\section{Agda}
\textit{Agda}~\cite{AgdaLang}~---  чистый функциональный язык программирования с зависимыми типами.
\input{latex/AgdaDescription.tex}

\section{Выводы по главе \ref{chapter1}}
Рассмотрены некоторые существующие подходы к построению структур данных
с использованием индуктивных семейств.
Кратко описаны особенности языка программирования \textit{Agda}.
