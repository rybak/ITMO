\chapter{Обзор
% предметной области
}
\label{chapter1}

\section{Функциональное программирование}
Функциональное программирование — парадигма программирования, 
в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании) \cite{wikiFP}.
В функциональном программировании избегается использование изменяемого глобального состояния и изменяемых данных.
\subsection{Концепции}
\emph{Функции высших порядков} — это такие функции, которые могут принимать
в качестве аргументов и возвращать другие функции \cite{SICP}.
\emph{Чистые функции} — функции, которые не имеют побочных эффектов
ввода-вывода и изменения памяти,
они зависят только от своих параметров и возвращают только свой результат.
\subsection{Сопоставление с образцом}
\emph{Сопоставление с образцом} — способ обработки структур данных,
при котором аргументы функций сравниваются (по значению или по структуре)
с образцом такого же типа.
\section{Теория типов}
\emph{Теория типов} — какая-либо формальная система, являющаяся альтернативой
наивной теории множеств, сопровождаемая классификацией элементов такой системы
с помощью типов, образующих некоторую иерархию.
Элементы теории типов — выражения, также называемые \emph{термами}.
Если терм $ M $ имеет тип $A$, то это записывают так: $ M : A $.
Например, $ 2 : \mathbb{N} $.

Теории типов также содержат правила для переписывания термов — замены
подтермов формулы другими термами.
Такие правила также называют правилами \emph{редукции}
или \emph{конверсии} термов.
Например, термы $2 + 1$ и $3$ — разные термы, но первый редуцируется во второй:
$2 + 1 \twoheadrightarrow 3$.
Про терм, который не может быть редуцирован, говорят,
что терм — в \emph{нормальной форме}.
\subsection{Отношение конвертабельности}
Два терма называются \emph{конвертабельными}, если существует терм, к которому
они оба редуцируются. Например, $1+2$ и $2+1$ — конвертабельны, как и термы
$x + (1 + 1)$ и $x + 2$. Однако, $x+1$ и $1+x$ (где $x$ — свободная переменная)
— не конвертабельны, так как оба представлены в нормальной форме.
\subsection{Интуиционистская теория типов}
Интуиционистская теория типов основана на математическом конструктивизме \cite{MLTT}.

Операторы для типов в ИТТ:
\begin{itemize}
    \item $\Pi$-тип (пи-тип) — зависимое произведение.
        Например, если $\operatorname{Vec}({\mathbb R}, n)$ — тип кортежей из $n$ вещественных чисел,
        $\mathbb N$ — тип натуральных чисел, то
        $\Pi_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}({\mathbb R}, n)$ 
        — тип функции, которая по натуральному числу $n$ возвращает кортеж из
        $n$ вещественных чисел.
    \item $\Sigma$-тип — зависимая сумма (пара).
        Например, тип $\Sigma_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}({\mathbb R}, n)$ — тип 
        пары из числа $n$ и кортежа из $n$ вещественных чисел.
\end{itemize}
Конечные типы в ИТТ:
$\bot$ или $0$ — пустой тип, не содержащий ни одного элемента;
$\top$ или $1$ — единичный тип, содержащий единственный элемент.
\emph{Тип равенства}: для $x$ и $y$ выражение
$x \equiv y$ обозначает тип доказательства равенства $x$ и $y$.
То есть, если тип $x \equiv y$ населен, то $x$ и $y$ называются равными.
Есть только один каноничный элемент типа $x \equiv x$ — доказательство
рефлексивности: $refl : \Pi_{a : A} a \equiv a $.
\section{Унификация}

Унификация — процесс и алгоритм решения уравнений над выражениями в теории типов.
Алгоритм унификации находит подстановку, которая назначает значение
каждой переменной в выражении, после применения которой,
части уравнения становятся конвертабельными.
Пример: равенство двух списков $cons(x,cons(x,nil)) \equiv cons(2,y) $
— уравнение с двумя переменными $x$ и $y$.
Решение: подстановка $ x \mapsto 2, y \mapsto cons(2,nil) $.

% * Очень кратко о ФП и паттерн-матчинге.
% * Кратко о теории типов, отношении конвертабельности и Мартине-Лёфе.
% * Кратко об унификации и индексированных семействах.
% * Кратко об Агда.
% * Об известных штуках кодируемых индексируемыми семействами (ссылки из
%   статьи МакБрайда).
\section{Индуктивные семейства}

\begin{definition}
\emph{Индуктивное семейство} \cite{DybjerIndFam}— это семейство типов данных,
которые могут зависеть от других типов и значений.

Тип или значение, от которого зависит зависимый тип, называют \emph{индексом}.
\end{definition}

Одной из областей применения индуктивных семейств являются системы интерактивного
доказательства теорем.

Индуктивные семейства позволяют формализовать математические структуры,
кодируя утверждения о структурах в них самих, тем самым перенося сложность из
доказательств в определения.

% \section{Существующие подходы}
В работах \cite{OkasakiThesis, McBridePivotal} приведены различные подходы
к построению функциональных структур данных.

Пример задания инвариантов для
структуры данных — тип данных для хранения баланса в AVL-дереве \cite{AVLTree}.
\newline
\input{latex/AVLBalance.tex}

\section{Agda}
\textit{Agda}~\cite{AgdaLang}~---  чистый функциональный язык программирования с зависимыми типами.
\input{latex/AgdaDescription.tex}

\section{Выводы по главе \ref{chapter1}}
Рассмотрены некоторые существующие подходы к построению структур данных
с использованием индуктивных семейств.
Кратко описаны особенности языка программирования \textit{Agda}.
