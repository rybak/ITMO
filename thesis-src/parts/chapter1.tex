\chapter{Обзор
% предметной области
}
\label{chapter1}

В данной главе производится обзор предметной области и даются определения используемых терминов.

\section{Лямбда-исчисление}

\emph{Лямбда-исчисление} ($\lambda$-calculus)~--- вычислительный формализм
с тремя синтаксическим конструкциями, называемыми \emph{пре-лямбда-термами}:
\begin{itemize}
\item \emph{вхождение переменной}: $v$. При этом $v \in V$, где $V$~--- некоторое множество имён переменных;
\item \emph{лямбда-абстракция}: $\lambda x.A$, где $x$~--- имя переменной, а $A$~--- пре-лямбда-терм. При этом терм $A$ называют \emph{телом абстракции}, а $x$ перед точкой~--- \emph{связыванием}.
\item \emph{лямбда-аппликация}: $B C$;
\end{itemize}
и одной операцией \emph{бета-редукции}.
При этом говорят, что вхождение переменной является \emph{свободным},
если оно не связано какой-либо абстракцией.
\emph{Лямбда-термы}~--- это пре-лямбда-термы, факторизованные по отношению \emph{альфа-эквивалентности}.

\emph{Альфа-эквивалентность} ($\alpha$-equality) отождествляет два пре-лямбда-терма, если один из них может быть получен из другого путём некоторого \emph{корректного} переименовывания переменных~--- переименования не нарушающего отношение связанности.

\emph{Бета-редукция} ($\beta$-reduction) для лямбда-терма $A$ выбирает в нём некоторую лямбда-аппликацию $B C$, содержащую лямбда-абстракцию в левой части $A$, и заменяет свободные вхождения переменной, связанной $A$, в теле самой $A$ на терм $C$.\footnote{В терминах пре-лямбда-термов это означает замену свободных вхождений в теле $A$ на пре-терм $C$ так, чтобы ни для каких переменных не нарушилось отношение связанности. То есть, в пре-терме $A$ следует корректно переименовать все связанные переменные, имена которых совпадают с именами свободных переменных в $C$.}

Два лямбда-терма $A$ и $B$ называются \emph{конвертабельными},
когда существует две последовательности бета-редукций, приводящих их к общему терму $C$.
Или, эквивалентно, когда термы $A$ и $B$ состоят с друг с другом в рефлексивно-симметрично-транзитивном замыкании отношения бета-редукции, также называемом отношением \emph{бета-эквивалентности}.

За более подробной информацией об этом формализме следует обращаться к~\cite{TTFP} и~\cite{Sorensen}.

\section{Функциональное программирование}

\emph{Функциональное программирование} — парадигма программирования,
являющаяся разновидностью декларативного программирования,
в которой программу представляют в виде функций
(математическом смысле этого слова, а не в смысле, используемом в процедурном программировании),
а выполнением программы считают вычисление значений применения этих функций к заданным значениям.
Большинство функциональных языков программирования используют в своём основании лямбда-исчисление
(например, Haskell~\cite{HaskellLang}, Curry~\cite{CurryLang}, Agda~\cite{AgdaLang},
диалекты LISP~\cite{SchemeLang,ClojureLang,SICP}, SML~\cite{SMLLang}, OCaml\cite{OCamlLang}),
но существуют и функциональные языки явно не основанные на этом формализме
(например, препроцессор языка C и шаблоны в C++).

\section{Алгебраические типы данных и сопоставление с образцом}

% надо подробнее в таком примерно роде что я сделал выше

\emph{Алгебраический тип данных} — вид составного типа, то есть типа,
сформированного комбинированием других типов.
Комбинирование осуществляется с помощью алгебраических операций — сложения и умножения.

\emph{Сумма} типов $A$ и $B$ — дизъюнктное объединение исходных типов.
Значения типа-суммы обычно создаются с помощью \emph{конструкторов}.

\emph{Произведение} типов $A$ и $B$ — прямое произведение исходных типов,
кортеж типов.

\subsection{Сопоставление с образцом}

\emph{Сопоставление с образцом} — способ обработки
объектов % | значений |
алгебраических типов данных, который идентифицирует значения по конструктору
и извлекает данные в соответствии с представленным образцом.

\section{Теория типов}

% ужасно от сюда и до Agda
% Теория типов — 
\emph{Теория типов} — раздел математики изучающий отношения типизации вида
$ M : \tau $ и их свойства. $M$ называется \emph{термом} или \emph{выражением},
а $\tau$ — типом терма $M$.

Теория типов также изучает правила для \emph{переписывания} термов — замены
подтермов в выражениях другими термами.
Такие правила также называют правилами \emph{редукции} или \emph{конверсии} термов.
Редукцию терма $x$ в терм $y$ записывают: $x \to y$.
Также рассматривают транзитивное замыкание отношения редукции: $ \xrightarrow{*} $.
Например, термы $2 + 1$ и $3$ — разные термы, но первый редуцируется во второй:
$2 + 1 \xrightarrow{*} 3$.
Если для терма $x$ не существует терма $y$, для которого $x \to y$,
то говорят, что терм $x$ — в \emph{нормальной форме}.

\subsection{Отношение конвертабельности}

Два терма $x$ и $y$ называются \emph{конвертабельными},
если существует терм $z$ такой, что $x \xrightarrow{*} z$ и $y \xrightarrow{*} z$. Обозначают  $x \xleftrightarrow{*} y$.
Например, $1+2$ и $2+1$ — конвертабельны, как и термы
$x + (1 + 1)$ и $x + 2$. Однако, $x+1$ и $1+x$ (где $x$ — свободная переменная)
— не конвертабельны, так как оба представлены в нормальной форме.
Конвертабельность — рефлексивно-транзитивно-симметричное замыкание отношения
редукции.

\subsection{Интуиционистская теория типов}

Интуиционистская теория типов основана на математическом конструктивизме \cite{MLTT}.

Операторы для типов в ИТТ:
\begin{itemize}
    \item $\Pi$-тип (пи-тип) — зависимое произведение.
        Например, если $\operatorname{Vec}({\mathbb R}, n)$ — тип кортежей из $n$ вещественных чисел,
        $\mathbb N$ — тип натуральных чисел, то
        $\Pi_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}({\mathbb R}, n)$ 
        — тип функции, которая по натуральному числу $n$ возвращает кортеж из
        $n$ вещественных чисел.
    \item $\Sigma$-тип — зависимая пара.
        Например, тип $\Sigma_{n \mathbin{:} {\mathbb N}} \operatorname{Vec}({\mathbb R}, n)$ — тип 
        пары из числа $n$ и кортежа из $n$ вещественных чисел.
\end{itemize}
Базовые типы в ИТТ:
$\bot$ или $0$ — пустой тип, не содержащий ни одного элемента;
$\top$ или $1$ — единичный тип, содержащий единственный элемент.

\emph{Индуктивный} или \emph{рекурсивный} тип~— тип данных, который может
содержать значения своего типа.

\section{Унификация}

\emph{Унификатор} для термов $A$ и $В$ — подстановка $S$, действующая на их
свободные переменные, такая что $S(A) \equiv S(B)$.

\emph{Унификация} — процесс поиска унификатора.

\section{Индуктивные семейства}

\begin{definition}
\emph{Индуктивное семейство} \cite{DybjerIndFam, RefiningIT}~— это индуктивный тип данных,
который может зависеть от других типов и значений.

Тип или значение, от которого зависит зависимый тип, называют \emph{индексом}.
\end{definition}

Одной из областей применения индуктивных семейств являются системы интерактивного
доказательства теорем.

Индуктивные семейства позволяют формализовать математические структуры,
кодируя утверждения о структурах в них самих, тем самым перенося сложность из
доказательств в определения.

% \section{Существующие подходы}
В работах \cite{HongweiXi, McBridePivotal} приведены различные подходы
в использовании индуктивных семейств в реализации структур данных
и доказательстве их свойств.

Пример задания структуры данных и инвариантов —
тип данных AVL-дерева и для хранения баланса в AVL-дереве \cite{AVLTree}.
\newline
\input{latex/AVLBalance.tex}

\section{Agda}
\emph{Agda}~\cite{AgdaLang}~---  чистый функциональный язык программирования с зависимыми типами.
\input{latex/AgdaDescription.tex}

\section{Выводы по главе \ref{chapter1}}

Рассмотрены некоторые существующие подходы к построению структур данных
с использованием индуктивных семейств.
Кратко описаны особенности языка программирования \textit{Agda}.
