В Agda есть поддержка модулей:
\begin{code}\>\<%
\\
\>\AgdaKeyword{module} \AgdaModule{AgdaDescription} \AgdaKeyword{where}\<%
\\
\>\<\end{code} В коде на Agda широко используются символы Unicode.
Тип натуральных чисел — \D{ℕ}.
\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℕ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{zero} \AgdaSymbol{:} \AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{succ} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℕ}\<%
\\
\>\<\end{code} \AgdaHide{
\begin{code}\>\<%
\\
\>\AgdaSymbol{\{-\#} \AgdaKeyword{BUILTIN} NATURAL \AgdaDatatype{ℕ} \AgdaSymbol{\#-\}}\<%
\\
\>\AgdaSymbol{\{-\#} \AgdaKeyword{BUILTIN} ZERO \AgdaInductiveConstructor{zero} \AgdaSymbol{\#-\}}\<%
\\
\>\AgdaSymbol{\{-\#} \AgdaKeyword{BUILTIN} SUC \AgdaInductiveConstructor{succ} \AgdaSymbol{\#-\}}\<%
\\
\>\<\end{code}
}
В Agda функции можно определять как mixfix операторы.
Пример — сложение натуральных чисел:
\begin{code}\>\<%
\\
\>\AgdaFunction{\_+\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℕ}\<%
\\
\>\AgdaInductiveConstructor{zero} \AgdaFunction{+} \AgdaBound{b} \AgdaSymbol{=} \AgdaBound{b}\<%
\\
\>\AgdaInductiveConstructor{succ} \AgdaBound{a} \AgdaFunction{+} \AgdaBound{b} \AgdaSymbol{=} \AgdaInductiveConstructor{succ} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{+} \AgdaBound{b}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
Символы подчеркивания обозначают места для аргументов.
% Система типов \textit{Agda} позволяет ... 
% В отличие от \textit{Haskell}, в \textit{Agda} имеется ... 

Зависимые типы позволяют определять типы, зависящие (индексированные) от значений
других типов. Пример — список, индексированный своей длиной:
\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Vec} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{nil} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaDatatype{Vec} \AgdaBound{A} \AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{cons} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Vec} \AgdaBound{A} \AgdaBound{n} \AgdaSymbol{→} \AgdaDatatype{Vec} \AgdaBound{A} \AgdaSymbol{(}\AgdaInductiveConstructor{succ} \AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
В фигурные скобки заключаются неявные аргументы.

Такое определение позволяет нам описать функцию $ \F{head} $ для такого списка, которая не может бросить исключение:
\begin{code}\>\<%
\\
\>\AgdaFunction{head} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Vec} \AgdaBound{A} \AgdaSymbol{(}\AgdaInductiveConstructor{succ} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{A}\<%
\\
\>\<\end{code}
У аргумента функции $ \F{head} $ тип $ \D{Vec}\,A\,(\DC{succ}\,n) $, то есть вектор, в котором есть хотя бы один элемент.
Это позволяет произвести сопоставление с образцом только по конструктору $ \DC{cons} $:
\begin{code}\>\<%
\\
\>\AgdaFunction{head} \AgdaSymbol{(}\AgdaInductiveConstructor{cons} \AgdaBound{a} \AgdaBound{as}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaBound{a}\<%
\\
\>\<\end{code}

